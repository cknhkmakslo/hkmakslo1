<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>水火箭發射模擬器 v2.0 (Water Rocket Simulator)</title>
    <style>
        /* CSS 樣式 - 大部分同之前一樣，只係加咗 zoom 按鈕嘅樣式 */
        body {
            font-family: 'Microsoft JhengHei', 'Heiti TC', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            background-color: #e0f7fa;
            color: #004d40;
        }

        h1 {
            color: #00796b;
            margin-top: 15px;
        }

        #main-container {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            padding: 15px;
        }

        #canvas-container {
            position: relative;
            border: 2px solid #00796b;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            background-color: #ffffff;
        }
        
        canvas {
            display: block;
        }

        #controls {
            width: 300px;
            padding: 20px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
        }

        .control-item label {
            font-weight: bold;
            margin-bottom: 8px;
            color: #004d40;
        }
        
        .value-display {
            font-weight: normal;
            color: #d84315;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        button {
            padding: 12px 20px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: white;
            transition: background-color 0.3s, transform 0.1s;
        }

        #launch-button { background-color: #d32f2f; }
        #launch-button:hover { background-color: #b71c1c; }
        #launch-button:active { transform: scale(0.98); }
        
        #reset-button { background-color: #1976d2; }
        #reset-button:hover { background-color: #0d47a1; }

        /* 【修改 1】: 新增 Zoom 按鈕嘅樣式 */
        .zoom-controls {
            display: flex;
            gap: 10px;
        }
        .zoom-controls button {
            flex-grow: 1; /* 令兩個掣一樣闊 */
            padding: 8px;
            font-size: 20px;
            background-color: #546e7a;
        }
        .zoom-controls button:hover {
            background-color: #37474f;
        }

        #results {
            margin-top: 10px;
            font-size: 16px;
            text-align: center;
        }
        #results p { margin: 5px 0; }

        @media (max-width: 800px) {
            #main-container { flex-direction: column; align-items: center; }
            #controls { width: 90%; max-width: 400px; }
        }
    </style>
</head>
<body>

    <h1>水火箭發射模擬器 v2.0</h1>

    <div id="main-container">
        <div id="controls">
            <h2>發射參數設定</h2>
            
            <div class="control-item">
                <label for="water-mass">注入水量: <span id="water-mass-value" class="value-display">987 g</span></label>
                <input type="range" id="water-mass" min="0" max="1974" value="987">
                <span>(火箭乾重: 26g)</span>
            </div>

            <div class="control-item">
                <label for="launch-angle">發射角度: <span id="launch-angle-value" class="value-display">45 °</span></label>
                <input type="range" id="launch-angle" min="0" max="90" value="45">
            </div>

            <!-- 【修改 2】: 加入縮放控制嘅 HTML 結構 -->
            <div class="control-item">
                <label>畫面縮放:</label>
                <div class="zoom-controls">
                    <button id="zoom-out-button">-</button>
                    <button id="zoom-in-button">+</button>
                </div>
            </div>

            <div class="control-item">
                <button id="launch-button">發射！</button>
            </div>
            <div class="control-item">
                <button id="reset-button">重設模擬</button>
            </div>

            <div id="results">
                <h3>飛行數據</h3>
                <p>水平距離: <span id="distance-value">---</span> m</p>
                <p>最大高度: <span id="max-height-value">---</span> m</p>
                <p>飛行時間: <span id="flight-time-value">---</span> s</p>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="simulation-canvas"></canvas>
        </div>
    </div>

    <script>
    // --- 1. 初始化同常數設定 ---
    
    // 獲取新增嘅 HTML 元素
    const zoomInButton = document.getElementById('zoom-in-button');
    const zoomOutButton = document.getElementById('zoom-out-button');
    // (其他元素獲取保持不變)
    const canvas = document.getElementById('simulation-canvas');
    const ctx = canvas.getContext('2d');
    const waterMassSlider = document.getElementById('water-mass');
    const waterMassValue = document.getElementById('water-mass-value');
    const angleSlider = document.getElementById('launch-angle');
    const angleValue = document.getElementById('launch-angle-value');
    const launchButton = document.getElementById('launch-button');
    const resetButton = document.getElementById('reset-button');
    const distanceDisplay = document.getElementById('distance-value');
    const maxHeightDisplay = document.getElementById('max-height-value');
    const flightTimeDisplay = document.getElementById('flight-time-value');

    const GRAVITY = 9.8;
    const ROCKET_DRY_MASS_KG = 0.026;
    
    // 【修改 3】: 將 PIXELS_PER_METER 變成一個可變嘅變數，並設定縮放限制
    let PIXELS_PER_METER = 5; // 初始值
    const MAX_ZOOM = 20;      // 最大放大比例
    const MIN_ZOOM = 0.5;     // 最小縮小比例
    const ZOOM_FACTOR = 1.2;  // 每次縮放嘅倍率

    let canvasWidth = Math.min(window.innerWidth * 0.6, 800);
    let canvasHeight = 400;
    canvas.width = canvasWidth;
    canvas.height = canvasHeight;

    // 定義畫布上嘅固定點
    const groundY = canvasHeight - 20;
    const originX = 30; // 發射點嘅 X 座標

    let rocket = {};
    let trajectory = [];
    let animationId;
    let isFlying = false;

    // --- 2. 核心物理模型 (無變動) ---
    function calculateInitialVelocity(waterMassGrams) {
        const maxWaterMass = 1974;
        const maxVelocity = 80;
        if (waterMassGrams <= 0) return 0;
        let velocity = maxVelocity * Math.sin((waterMassGrams / maxWaterMass) * Math.PI);
        return velocity > 0 ? velocity : 0;
    }

    // --- 3. 繪圖函式 (無變動) ---
    function drawRocket(x, y, angle) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);
        ctx.fillStyle = '#d32f2f';
        ctx.fillRect(-15, -5, 30, 10);
        ctx.fillStyle = '#fbe9e7';
        ctx.beginPath();
        ctx.moveTo(15, -5);
        ctx.lineTo(25, 0);
        ctx.lineTo(15, 5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    function drawTrajectory() {
        if (trajectory.length === 0) return;
        ctx.beginPath();
        ctx.strokeStyle = 'rgba(0, 77, 64, 0.5)';
        ctx.lineWidth = 2;
        ctx.moveTo(trajectory[0].x, trajectory[0].y);
        for (let i = 1; i < trajectory.length; i++) {
            ctx.lineTo(trajectory[i].x, trajectory[i].y);
        }
        ctx.stroke();
    }

    function draw() {
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = '#4caf50';
        ctx.fillRect(0, groundY, canvasWidth, 20);
        ctx.fillStyle = '#8d6e63';
        ctx.fillRect(0, groundY, canvasWidth, 5);

        if (trajectory.length > 0) {
            drawTrajectory();
            ctx.fillStyle = '#1976d2';
            ctx.beginPath();
            ctx.arc(trajectory[0].x, trajectory[0].y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.font = '12px Arial';
            ctx.fillText('Start', trajectory[0].x - 15, trajectory[0].y + 15);
        }

        drawRocket(rocket.x, rocket.y, rocket.angle);

        if (!isFlying && trajectory.length > 1) {
            const lastPoint = trajectory[trajectory.length - 1];
            ctx.fillStyle = '#d84315';
            ctx.beginPath();
            ctx.arc(lastPoint.x, lastPoint.y, 5, 0, 2 * Math.PI);
            ctx.fill();
            ctx.font = '12px Arial';
            ctx.fillText('End', lastPoint.x - 10, lastPoint.y + 15);
        }
    }

    // --- 4. 模擬主循環 (無變動) ---
    let lastTime = 0;
    function update(time) {
        if (!isFlying) return;

        if (lastTime > 0) {
            const deltaTime = (time - lastTime) / 1000;
            rocket.vy += GRAVITY * deltaTime;
            
            // 老師解說：呢度嘅物理計算係用米做單位，但係儲存嘅 rocket.x, .y 同 trajectory 係用像素做單位。
            // 呢個設計喺加入縮放功能後會變得好複雜。一個更理想嘅做法係將物理座標(米)同螢幕座標(像素)完全分開。
            // 但為咗保持程式碼結構簡單，我哋會喺縮放時直接重新計算所有像素座標。
            const dx_meters = rocket.vx * deltaTime;
            const dy_meters = rocket.vy * deltaTime;

            rocket.x += dx_meters * PIXELS_PER_METER;
            rocket.y += dy_meters * PIXELS_PER_METER;
            
            rocket.angle = Math.atan2(rocket.vy, rocket.vx);
            trajectory.push({ x: rocket.x, y: rocket.y });
            
            if (rocket.y >= groundY) {
                endFlight();
                return;
            }
        }

        lastTime = time;
        draw();
        animationId = requestAnimationFrame(update);
    }

    // --- 5. 控制與事件處理 ---

    function reset() {
        isFlying = false;
        cancelAnimationFrame(animationId);
        lastTime = 0;
        trajectory = [];

        rocket = {
            x: originX,
            y: groundY,
            vx: 0,
            vy: 0,
            angle: -Math.PI / 4
        };
        
        updateAngle();
        updateWaterMass();

        distanceDisplay.textContent = '---';
        maxHeightDisplay.textContent = '---';
        flightTimeDisplay.textContent = '---';

        draw();

        launchButton.disabled = false;
        waterMassSlider.disabled = false;
        angleSlider.disabled = false;
        launchButton.style.backgroundColor = '#d32f2f';
    }

    function launch() {
        if (isFlying) return;
        
        // 發射前重設軌跡，但保留火箭位置同角度
        trajectory = [];
        lastTime = 0;

        launchButton.disabled = true;
        waterMassSlider.disabled = true;
        angleSlider.disabled = true;
        launchButton.style.backgroundColor = '#9e9e9e';

        const waterMass = parseFloat(waterMassSlider.value);
        const launchAngleRad = parseFloat(angleSlider.value) * Math.PI / 180;
        const v0 = calculateInitialVelocity(waterMass);

        rocket.vx = v0 * Math.cos(launchAngleRad);
        rocket.vy = -v0 * Math.sin(launchAngleRad);

        // 重設火箭到發射點，並記錄軌跡起點
        rocket.x = originX;
        rocket.y = groundY;
        trajectory.push({ x: rocket.x, y: rocket.y });
        
        isFlying = true;
        animationId = requestAnimationFrame(update);
    }

    function endFlight() {
        isFlying = false;
        cancelAnimationFrame(animationId);
        
        // 確保火箭精確停喺地面
        rocket.y = groundY;

        const startX_pixels = trajectory[0].x;
        const endX_pixels = rocket.x;
        const distance = (endX_pixels - startX_pixels) / PIXELS_PER_METER;

        let maxHeight = 0;
        trajectory.forEach(p => {
            const height = (groundY - p.y) / PIXELS_PER_METER;
            if (height > maxHeight) {
                maxHeight = height;
            }
        });
        
        const flightTime = (lastTime > 0 && animationId) ? (performance.now() - (lastTime - (1000/60)))/1000 : 0; // 估算
        
        distanceDisplay.textContent = distance.toFixed(2);
        maxHeightDisplay.textContent = maxHeight.toFixed(2);
        flightTimeDisplay.textContent = flightTime.toFixed(2);

        draw();
    }

    function updateAngle() {
        const angleDeg = angleSlider.value;
        angleValue.textContent = `${angleDeg} °`;
        if (!isFlying) {
            rocket.angle = -angleDeg * Math.PI / 180;
            draw();
        }
    }
    
    function updateWaterMass() {
        waterMassValue.textContent = `${waterMassSlider.value} g`;
    }
    
    // 【修改 4】: 實現縮放功能嘅核心函式
    function zoom(direction) {
        const oldPPM = PIXELS_PER_METER;
        let newPPM = oldPPM;

        if (direction === 'in') {
            newPPM *= ZOOM_FACTOR;
        } else {
            newPPM /= ZOOM_FACTOR;
        }

        // 限制縮放範圍
        newPPM = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newPPM));

        if (newPPM === oldPPM) return; // 如果無變化就唔做任何嘢

        const scaleRatio = newPPM / oldPPM;
        PIXELS_PER_METER = newPPM;

        // 老師解說：呢度係最關鍵嘅一步！
        // 我哋需要更新所有現存物件嘅像素座標，令佢哋喺新嘅比例尺下位置正確。
        // 更新嘅原則係：物件相對於「固定點」（我哋定為發射點 originX, groundY）嘅距離，
        // 按照新舊比例尺嘅比例進行縮放。

        // 更新火箭位置
        rocket.x = originX + (rocket.x - originX) * scaleRatio;
        rocket.y = groundY + (rocket.y - groundY) * scaleRatio;

        // 更新所有軌跡點
        for (let i = 0; i < trajectory.length; i++) {
            trajectory[i].x = originX + (trajectory[i].x - originX) * scaleRatio;
            trajectory[i].y = groundY + (trajectory[i].y - groundY) * scaleRatio;
        }

        // 重新繪製整個場景
        draw();
    }

    // 綁定事件監聽器
    launchButton.addEventListener('click', launch);
    resetButton.addEventListener('click', reset);
    angleSlider.addEventListener('input', updateAngle);
    waterMassSlider.addEventListener('input', updateWaterMass);

    // 【修改 5】: 綁定新按鈕嘅事件
    zoomInButton.addEventListener('click', () => zoom('in'));
    zoomOutButton.addEventListener('click', () => zoom('out'));


    // --- 6. 程式啟動 ---
    window.addEventListener('load', reset);

    </script>

</body>
</html>

### 老師課堂總結：新功能解說

各位同學，我哋已經成功為模擬器加入咗縮放功能！請留意以下幾點重要嘅修改：

1.  **HTML 界面更新：**
    我哋喺控制面板加入咗兩個新按鈕，`id` 分別係 `zoom-in-button` 同 `zoom-out-button`，並用 CSS 俾咗佢哋簡單嘅樣式。

2.  **引入縮放變數：**
    喺 JavaScript 部分，原本嘅 `const PIXELS_PER_METER`（常數）已經被改為 `let PIXELS_PER_METER`（變數），咁樣我哋先可以喺程式運行期間改變佢嘅值。同時，我哋加入咗 `MAX_ZOOM` 同 `MIN_ZOOM` 去限制縮放嘅上下限，避免用戶過度放大或縮小導致畫面異常。

3.  **`zoom()` 核心函式：**
    呢個係新加嘅函式，負責處理所有縮放邏輯。
    *   佢首先根據 `direction`（'in' 或 'out'）計算出新嘅比例尺 `newPPM`。
    *   然後，計算出新舊比例尺之間嘅比率 `scaleRatio`。
    *   **最關鍵嘅一步**：佢遍歷咗火箭 `rocket` 同軌跡 `trajectory` 數組入面嘅每一個點，將佢哋嘅 `x` 同 `y` 座標，根據 `scaleRatio` 相對於發射點 (`originX`, `groundY`) 進行重新計算。呢個步驟確保咗就算你喺飛行途中縮放，成條軌跡都會平滑、正確地跟住一齊縮放，而唔會斷開或變形。
    *   最後，調用 `draw()` 函式，用新計算出嚟嘅座標重新繪製整個場景。

4.  **事件綁定：**
    最後，我哋為新嘅縮放按鈕加上 `addEventListener`，令到用戶點擊佢哋嘅時候，可以正確觸發 `zoom()` 函式。

而家，你哋可以試下發射一支飛得好遠嘅火箭，然後用「-」掣縮小畫面，睇晒佢完整嘅飛行路徑。你亦都可以喺火箭仲飛緊嘅時候進行縮放，觀察成個畫面點樣即時變化。

呢次嘅修改，唔單止令我哋嘅模擬器更實用，仲教識我哋一個重要嘅編程概念：**點樣處理動態座標系統嘅轉換**。希望大家都有所收穫！
